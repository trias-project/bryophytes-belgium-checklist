---
title: "Darwin Core mapping"
subtitle: "For: Bryophyte checklist and European red list of the Brussels-Capital Region, Flanders and Wallonia (Belgium)"
author:
- Lien Reyserhove
- Peter Desmet
- Quentin Groom
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/rinse-pathways-checklist/blob/master/src/dwc_mapping.Rmd).

# Setup

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse) # To transform data
library(magrittr)  # For %<>% pipes
library(here)           # To find files
library(janitor)   # To clean input data
library(readxl)    # To read Excel files
library(digest)    # To generate hashes
library(rgbif)     # To parse names
```

# Read source data

Create a data frame `input_data` from the source data:

```{r}
input_data <- read_excel(path = here("data", "raw", "bryophytes.xlsx")) 
```

Preview data:

```{r}
input_data %>% head(n = 5)
```

# Process source data

## Tidy data

Clean data somewhat:

```{r}
input_data %<>% 
  remove_empty("rows") %<>%
  clean_names()
```

## Scientific names

Use the [GBIF nameparser](https://www.gbif.org/tools/name-parser) to retrieve nomenclatural information for the scientific names in the checklist:

## Taxon IDs

To link taxa with information in the extension(s), each taxon needs a unique and relatively stable `taxonID`. Here we create one in the form of `dataset_shortname:taxon:hash`, where `hash` is unique code based on scientific name (that will remain the same as long as scientific name remain the same):

```{r}
vdigest <- Vectorize(digest) # Vectorize digest function to work with vectors
input_data %<>% mutate(taxon_id = paste(
  "bryophytes-belgium-checklist", 
  "taxon",
  vdigest(taxon, algo = "md5"),
  sep = ":"
))
```

Preview data:

```{r}
input_data %>% head()
```

# Taxon core

## Pre-processing

Create a dataframe with unique taxa only (ignoring multiple distribution rows):

```{r}
taxon <- input_data %>% distinct(taxon_id, .keep_all = TRUE)
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

### language

```{r}
taxon %<>% mutate(dwc_language = "en")
```

### license

```{r}
taxon %<>% mutate(dwc_license = "http://creativecommons.org/publicdomain/zero/1.0/") 
```

### rightsHolder

```{r}
taxon %<>% mutate(dwc_rightsHolder = "Botanical Garden Meise")
```

### datasetID

```{r}
taxon %<>% mutate(dwc_datasetID = "")
```

### institutionCode

```{r}
taxon %<>% mutate(dwc_institutionCode = "BGM") 
```

### datasetName

```{r}
taxon %<>% mutate(dwc_datasetName = "Bryophyte checklist and European red list of the Brussels-Capital Region, Flanders and Wallonia (Belgium)") 
```

### taxonID	

```{r}
taxon %<>% mutate(dwc_taxonID = taxon_id) 
```

### scientificName

```{r}
taxon %<>% mutate(dwc_scientificName = taxon) 
```

### kingdom

```{r}
taxon %<>% mutate(dwc_kingdom = "Plantae") 
```

### phylum

```{r}
taxon %<>% mutate(dwc_phylum = division) 
```

### taxonRank

The nameparser function provided by rgbif returns information about the rank of the taxon (in `rankmarker`). We extract this information and join this information with our checklist. 

Extract rankmarker information:

```{r}
parsed_names <- input_data %>%
  distinct(taxon) %>%
  pull() %>% # Create vector from dataframe
  parsenames() %>% # An rgbif function
  select(scientificname, rankmarker)
```

Join this information with `taxon`:

```{r}
taxon %<>% left_join(parsed_names,
  by = c("taxon" = "scientificname"))
```

Show unique return for `rankmarker`:

```{r}
taxon %>% distinct(rankmarker)
```

Recode values:

```{r}
taxon %<>% mutate(dwc_taxonRank = recode(rankmarker,
  "infrasp."  = "infraspecificname",
  "sp."       = "species",
  "var."      = "variety",
  .default    = "",
  .missing    = ""
))
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(dwc_nomenclaturalCode = "ICN")  
```

## Post-processing

Only keep the Darwin Core columns:

```{r}
taxon %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(taxon) <- str_replace(colnames(taxon), "dwc_", "")
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
```

# Create distribution extension

```{r start_distribution}
distribution <- input_data
```

## Pre-processing

Before we start mapping the distribution extensions, we focus on two terms: `occurrenceStatus` and  `eventDate`. This is because information on the occurrences is given for the **regions**, while date information is given for **Belgium** as a whole. Some transformations and clarifications are needed.

The checklist contains minimal presence information (`1`,`?` or `0`) for the three regions in Belgium: Flanders, Wallonia and the Brussels-Capital Region. Information regarding the first/last recorded observation applies to the distribution in Belgium as a whole. Both national and regional information is required in the checklist. In the `distribution.csv`, we will first provide `occurrenceStatus` and `eventDate`` on a **national level**, followed by specific information for the **regions**. 

For this, we use the following principles:

1. When a species is present in _only one region_, we can assume `eventDate` relates to that specific region. In this case, we can keep lines for Belgium and for the specific region populated with these variables.

2. When a species is present in _more than one_ region, it is impossible to extrapolate the date information for the regions. In this case, we decided to provide `occurrenceStatus` for the regional information, and specify dates only for Belgium.  

Thus, we need to specify when a species is present in only one of the regions.

We generate 4 new columns: `presence_flanders`, `presence_brussels`,`presence_wallonia` and `presence_belgium`. 
The content of these columns refers to the specific presence status of a species on a regional or national level.
`S` if present in a single region or in Belgium, `?` if presence uncertain, `NA` if absent and `M` if present in multiple regions.

This should look like this:
```{r echo=FALSE}
as.data.frame(matrix(
  c(
    "0", "0", "1", NA, NA, "S", "S",
    "0", "1", "0", NA, "S", NA, "S", 
    "0", "1", "1", NA, "M", "M", "S",
    "1", "?", "?", "S", "?", "?", "S",
    "1", "0", "0", "S", NA, NA, "S",
    "1", "0", "1", "M", NA, "M", "S",
    "1", "1", "0", "M", "M", NA, "S",
    "1", "1", "1", "M", "M", "M", "S"
  ),
  ncol = 7,
  byrow = TRUE,
  dimnames = list(c(1:8), c(
    "flanders",
    "wallonia", 
    "brussels", 
    "presence_flanders", 
    "presence_wallonia", 
    "presence_brussels",
    "presence_belgium"
  ))
))
```

We translate this to the distribution extension:

Flanders:

```{r}
distribution %<>% mutate(presence_flanders = case_when(
  flanders == "1" & 
    (wallonia == "?" | wallonia == "0") &
    (brussels == "?" | brussels == "0") ~ "S",
  flanders == "0" ~ "NA",
  TRUE ~ "M"))
```

Wallonia:

```{r}
distribution %<>% mutate(presence_wallonia = case_when(
  wallonia == "1" &
    flanders == "0" &
    brussels == "0" ~ "S",
  wallonia == "?" ~"?",
  wallonia == "0" ~ "NA",
  TRUE ~ "M"
))
```

Brussels:

```{r}
distribution %<>% mutate(presence_brussels = case_when(
  brussels == "1" &
    flanders == "0" &
    wallonia == "0" ~ "S",
  brussels == "?" ~ "?",
  brussels == "0" ~ "NA",
  TRUE ~ "M"
)) 
```

Belgium:

```{r}
distribution %<>% mutate(presence_belgium = "S") 
```

Summary of the previous action:

```{r}
distribution %>% select (flanders, wallonia, brussels, presence_flanders, presence_wallonia, presence_brussels, presence_belgium) %>%
  group_by_all() %>%
  summarize(records = n()) %>%
  arrange(presence_flanders, presence_wallonia, presence_brussels)
```

One line should represent the presence information of a species in one region or Belgium. We need to transform `distribution` from a wide to a long table (i.e. create a `key` and `value` column):

```{r}
distribution %<>% gather(
  key, value,
  presence_flanders, presence_wallonia, presence_brussels, presence_belgium,
  convert = FALSE
) 
```

Rename `key` and `value`:

```{r}
distribution %<>% rename("location" = "key", "presence" = "value")
```

Remove prefix in `location`:

```{r}
distribution %<>% mutate(location = str_replace_all(location, "presence_", ""))
```

Remove species for which we lack presence information (i.e. `presence` = `NA``):

```{r}
distribution %<>% filter (!presence == "NA")
```

## Term mapping

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### taxonID

```{r}
distribution %<>% mutate(dwc_taxonID = taxon_id)
```

### locationID

```{r}
distribution %<>% mutate(dwc_locationID = case_when (
  location == "belgium" ~ "ISO_3166-2:BE",
  location == "flanders" ~ "ISO_3166-2:BE-VLG",
  location == "wallonia" ~ "ISO_3166-2:BE-WAL",
  location == "brussels" ~ "ISO_3166-2:BE-BRU"))
```

### locality

```{r}
distribution %<>% mutate(dwc_locality = case_when (
  location == "belgium"  ~ "Belgium",
  location == "flanders" ~ "Flemish Region",
  location == "wallonia" ~ "Walloon Region",
  location == "brussels" ~ "Brussels-Capital Region"))
```

### countryCode

```{r}
distribution %<>% mutate(dwc_countryCode = "BE")
```

### establishmentMeans

Information for `establishmentMeans` is contained in the field `origin`:

```{r}
distribution %>% distinct(origin)
```

We map these values to the [GBIF vocabulary for establishmentMeans](http://rs.gbif.org/vocabulary/gbif/establishment_means.xml):

```{r}
distribution %<>% mutate(dwc_establishmentMeans = recode(origin,
    "alien"       = "introduced",
    "Cryptogenic" = "uncertain"))
```

### occurrenceStatus

All taxa in this checklist can be considered as present in Belgium.

```{r}
distribution %<>% mutate(dwc_occurrenceStatus = "present") 
```

### threatStatus

```{r}
distribution %<>% distinct(european_red_list_species) 
```



### eventDate

### Clean date information

Inspect date information: 

```{r}
distribution %>% 
  group_by(origin, date_from, date_to) %>%
  summarize(records = n())
```

For species with date information `extinct`, we decided to leave date information empty. 
For species with `date_from` = `absent`, we decided to set this value to `2007`, i.e. the same as `date_to`, as the species was cryptogenic (`origin`) at that time point. We recode and clean the date information.

```{r}
distribution %<>% mutate(date_from = recode(date_from,
  "absent"  = "2007",
  "c. 1900" = "1900",
  "extinct" = "",
  .missing = ""
))
```


```{r}
distribution %<>% mutate(date_to = recode(date_to,
  "<1900" = "1900",
  "extinct" = "",
  .missing = ""
))
```



### source

### occurrenceRemarks

## Post-processing

Only keep the Darwin Core columns:

```{r}
distribution %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(distribution) <- str_replace(colnames(distribution), "dwc_", "")
```

Preview data:

```{r}
distribution %>% head()
```

Save to CSV:

```{r}
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
```


