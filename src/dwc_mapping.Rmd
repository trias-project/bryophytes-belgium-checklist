---
title: "Darwin Core mapping"
subtitle: "For: Bryophyte checklist and European red list of the Brussels-Capital Region, Flanders and Wallonia (Belgium)"
author:
- Lien Reyserhove
- Peter Desmet
- Quentin Groom
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
---

This document describes how we map the checklist data to Darwin Core. The source file for this document can be found [here](https://github.com/trias-project/rinse-pathways-checklist/blob/master/src/dwc_mapping.Rmd).

# Setup

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Set locale (so we use UTF-8 character encoding):

```{r}
# This works on Mac OS X, might not work on other OS
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")
```

Load libraries:

```{r}
library(tidyverse) # To transform data
library(magrittr)  # For %<>% pipes
library(janitor)   # To clean input data
library(readxl)    # To read Excel files
library(digest)    # To generate hashes
library(rgbif)     # To parse names
```

Set file paths (all paths should be relative to this script):
 
```{r}
# Raw files:
raw_data_file = "../data/raw/bryophytes.xlsx"

# Processed files:
dwc_taxon_file = "../data/processed/taxon.csv"
dwc_distribution_file = "../data/processed/distribution.csv"
dwc_description_file = "../data/processed/description.csv"
```

# Read and pre-process raw data

Create a data frame `raw_data` from the source data:

```{r}
raw_data <- read_excel(path = raw_data_file) 
```

Clean the data somewhat: remove empty rows if present and clean names:

```{r}
raw_data %<>% 
  remove_empty("rows") %<>%
  clean_names()
```

## Generate taxonID

To uniquely identify a taxon in the taxon core and reference taxa in the extensions, we need a `taxonID`. Since we need it in all generated files, we generate it here in the raw data frame. It is a combination of `dataset-shortname:taxon:` and a hash based on the scientific name. As long as the scientific name doesn't change, the ID will be stable. S

Generate `taxonID`:

```{r}
# Vectorize the digest function (the digest() function isn't vectorized. So if you pass in a vector, you get one value for the whole vector rather than a digest for each element of the vector):
vdigest <- Vectorize(digest)

# Generate taxonID:
raw_data %<>% mutate(taxonID = paste("bryophytes-belgium-checklist", "taxon", vdigest (taxon, algo = "md5"), sep = ":"))
```

## Further pre-processing

Add prefix `raw_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(raw_data) <- paste0("raw_", colnames(raw_data))
```

Preview data:

```{r}
raw_data %>% head()
```

# Create taxon core

```{r start_taxon}
taxon <- raw_data
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

### language

```{r}
taxon %<>% mutate(language = "en")
```

### license

```{r}
taxon %<>% mutate(license = "http://creativecommons.org/publicdomain/zero/1.0/") 
```

### rightsHolder

```{r}
taxon %<>% mutate(rightsHolder = "Botanical Garden Meise")
```

### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

### institutionCode

```{r}
taxon %<>% mutate(institutionCode = "BGM") 
```

### datasetName

```{r}
taxon %<>% mutate(datasetName = "Bryophyte checklist and European red list of the Brussels-Capital Region, Flanders and Wallonia (Belgium)") 
```

### taxonID	

```{r}
taxon %<>% mutate(taxonID = raw_taxonID) 
```

### scientificName

```{r}
taxon %<>% mutate(scientificName = raw_taxon) 
```

### kingdom

```{r}
taxon %<>% mutate(kingdom = "Plantae") 
```

### phylum

```{r}
taxon %<>% mutate(phylum = raw_division) 
```

### taxonRank

Almost all taxa are species, only `Tortella inclinata (R.Hedw.) Limpr. var. densa` is a variety:

```{r}
taxon %<>% mutate(taxonRank = case_when(
  raw_taxon == "Tortella inclinata (R.Hedw.) Limpr. var. densa" ~ "variety",
  TRUE ~ "species")) 
```

### nomenclaturalCode

```{r}
taxon %<>% mutate(nomenclaturalCode = "ICN")  
```

## Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("raw_"))
```

Sort on `taxonID`:

```{r}
taxon %<>% arrange(taxonID)
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write.csv(taxon, file = dwc_taxon_file, na = "", row.names = FALSE, fileEncoding = "UTF-8")
```

# Create distribution extension

```{r start_distribution}
distribution <- raw_data
```

## Pre-processing

Before we start mapping the distribution extensions, we focus on two terms: `occurrenceStatus` and  `eventDate`. This is because information on the occurrences is given for the **regions**, while date information is given for **Belgium** as a whole. Some transformations and clarifications are needed.

The checklist contains minimal presence information (`1`,`?` or `0`) for the three regions in Belgium: Flanders, Wallonia and the Brussels-Capital Region, contained in `raw_flanders`, `raw_wallonia` and `raw_brussels` respectively. Information regarding the first/last recorded observation applies to the distribution in Belgium as a whole. Both national and regional information is required in the checklist. In the `distribution.csv`, we will first provide `occurrenceStatus` and `eventDate`` on a **national level**, followed by specific information for the **regions**. 

For this, we use the following principles:

1. When a species is present in _only one region_, we can assume `eventDate` relates to that specific region. In this case, we can keep lines for Belgium and for the specific region populated with these variables.

2. When a species is present in _more than one_ region, it is impossible to extrapolate the date information for the regions. In this case, we decided to provide `occurrenceStatus` for the regional information, and specify dates only for Belgium.  

Thus, we need to specify when a species is present in only one of the regions.

We generate 4 new columns: `Flanders`, `Brussels`,`Wallonia` and `Belgium`. 
The content of these columns refers to the specific presence status of a species on a regional or national level.
`S` if present in a single region or in Belgium, `?` if presence uncertain, `NA` if absent and `M` if present in multiple regions.

This should look like this:
```{r echo=FALSE}
as.data.frame(matrix(
  c(
    "0", "0", "1", NA, NA, "S", "S",
    "0", "1", "0", NA, "S", NA, "S", 
    "0", "1", "1", NA, "M", "M", "S",
    "1", "?", "?", "S", "?", "?", "S",
    "1", "0", "0", "S", NA, NA, "S",
    "1", "0", "1", "M", NA, "M", "S",
    "1", "1", "0", "M", "M", NA, "S",
    "1", "1", "1", "M", "M", "M", "S"
  ),
  ncol = 7,
  byrow = TRUE,
  dimnames = list(c(1:8), c(
    "raw_flanders",
    "raw_wallonia", 
    "raw_brussels", 
    "Flanders", 
    "Wallonia", 
    "Brussels",
    "Belgium"
  ))
))
```

We translate this to the distribution extension:

Flanders:

```{r}
distribution %<>% mutate(Flanders = case_when(
  raw_flanders == "1" & 
    (raw_wallonia == "?" | raw_wallonia == "0") &
    (raw_brussels == "?" | raw_brussels == "0") ~ "S",
  raw_flanders == "0" ~ "NA",
  TRUE ~ "M"))
```

Wallonia:

```{r}
distribution %<>% mutate(Wallonia = case_when(
  raw_wallonia == "1" &
    raw_flanders == "0" &
    raw_brussels == "0" ~ "S",
  raw_wallonia == "?" ~"?",
  raw_wallonia == "0" ~ "NA",
  TRUE ~ "M"
))
```

Brussels:

```{r}
distribution %<>% mutate(Brussels = case_when(
  raw_brussels == "1" &
    raw_flanders == "0" &
    raw_wallonia == "0" ~ "S",
  raw_brussels == "?" ~ "?",
  raw_brussels == "0" ~ "NA",
  TRUE ~ "M"
)) 
```

Belgium:

```{r}
distribution %<>% mutate(Belgium = "S") 
```

Summary of the previous action:

```{r}
distribution %>% select (raw_flanders, raw_wallonia, raw_brussels, Flanders, Wallonia, Brussels, Belgium) %>%
  group_by_all() %>%
  summarize(records = n()) %>%
  arrange(Flanders, Wallonia, Brussels)
```

One line should represent the presence information of a species in one region or Belgium. We need to transform `raw_data` from a wide to a long table (i.e. create a `key` and `value` column):

```{r}
distribution %<>% gather(
  key, value,
  Flanders, Wallonia, Brussels, Belgium,
  convert = FALSE
) 
```

Rename `key` and `value`:

```{r}
distribution %<>% rename ("location" = "key", "presence" = "value")
```

Remove species for which we lack presence information (i.e. `presence` = `NA``):

```{r}
distribution %<>% filter (!presence == "NA")
```

### Clean date information

Inspect `raw_date_from`: 

```{r}
distribution %>% distinct(raw_date_from)
```

